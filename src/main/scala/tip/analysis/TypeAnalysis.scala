package tip.analysis

import tip.ast.DepthFirstAstVisitor
import tip.solvers._
import tip.ast._
import tip.types._
import scala.collection.{ mutable, immutable }

/**
 * The analysis associates with each node in the AST a [[tip.types.TipType]].
 * The associated term is meant to represent a TipType (when the inference has established
 * a definite type), a TipType with open variables (when the inference has not inferred the identity
 * of all the types appearing as subterms) and a rational recursive TipType in the case of [[tip.types.Mu]].
 */
case class TypeAnalysis(program: AProgram)
  extends DepthFirstAstVisitor[Null] {

  val solver = new UnionFindSolver[TipType]()
  var constraints = Set[Constraint]()

  performAnalysis()

  /**
   * Returns the set of constraints that are generated by analysis.
   * Note that we collect them only for debugging purposes - the solving happens on-the-fly.
   * @return the set of constraints
   */
  def generatedConstraints(): Set[Constraint] = constraints

  /**
   * Generates the constraint t1 == t2 for the solver, and record it in `constraints`.
   */
  private def unifyAndRecord(t1: Term[TipType], t2: Term[TipType], genId: String): Unit = {
    constraints = constraints + Constraint(t1, t2, genId)
    solver.unify(t1, t2)
  }

  /**
   * Generates the constraints for the given sub-AST.
   * @param node the node for which it generates the constraints
   * @param arg unused for this visitor
   */
  override def visit(node: AstNode, arg: Null): Unit = {
    visitChildren(node, null)
  }

  private def performAnalysis(): Unit = {

    // Generate the constraints
    visit(program, null)

    // Now that we have the solution we can attach the it to the AST
    new DepthFirstAstVisitor[Null] {
      val sol = solver.solution()

      visit(program, null)

      /**
       * Closes a type by replacing each variable that appears as a subterm
       * of `t` with the solution.
       * Whenever a recursive type is detected a [[Mu]] type is generated.
       *
       * @param t the term to close
       * @param visited the set of already visited variables
       * @return the closed term
       */
      private def closeTerm(t: Term[TipType], visited: Set[Var[TipType]] = Set()): Term[TipType] = {
        t match {
          case v: Var[TipType] =>
            if (!visited.contains(v) && (sol(v) != v)) {
              val cterm = closeTerm(sol(v), visited + v)
              if (cterm.fv.contains(v)) {
                Mu[TipType](v, cterm)
              }
              else
                cterm
            }
            else {
              v
            }
          case _ =>
            t.fv.foldLeft(t) { (st, v) =>
              st.subst(v, closeTerm(v, visited))
            }
        }
      }

      override def visit(node: AstNode, arg: Null): Unit = {
        val nodeSol = node match {
          case e: AExpr => e.meta.theType = Some(closeTerm(node).asInstanceOf[TipType])
          case e: AFunDeclaration => e.meta.theType = Some(closeTerm(e.name).asInstanceOf[TipType])
          case _ =>
        }
        visitChildren(node, null)
      }
    }
  }
}

/**
 * A class representing an equality constraint t1 == t2.
 *
 * @param t1 the left-hand of the constraint
 * @param t2 the right-hand side of the constraint
 * @param gen a string representing where the constraint is generated w.r.t. the program
 */
case class Constraint(t1: Term[TipType], t2: Term[TipType], gen: String) {
  override def toString: String = s"[${gen.padTo(20, ' ')}] $t1 == $t2"
}
